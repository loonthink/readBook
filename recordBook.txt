object 
	①创建对象的两种方式
		var obj = new Object();
			obj.name = 'aa';
			或者
			直接使用 ②对象字面量 包裹
		var obj = {
			name:'aa',
			1:'aaadd'
		}
		③key可以不使用 引号包裹 但是不使用引号包裹的话 遇到非法字符 就会报错
		如：
		var obj = {
			3333name:999
		}  定义直接导致报错   加上 引号 就好了 访问的时候 使用 中括号[] 来访问
		
		④对于 含有特殊字符的key 最好使用 中括号包裹的方式来求值

原生
	原生 改动class
		el.className  获取到的 是字符串
		el.classList  获取到的 是一个对象
			el.classList.add('className')
			el.classList.remove('className') 
		
		
		
es6
	转换为数组
	
	① 传参为多个
	Array.of(1,2,3,6,5) 将参数转换为 数组 ==> [1,2,3,6,5]
		注意 str.split('') 参数 是要传递 以什么格式转为切割符转换为数组的
	② 传参为一个整的字符串
	Array.from() 
		①将类数组 或 可遍历的对象 转换为真正的对象
		②将字符串转换为数组  Array.from('hello') ==> [h,e,l,l,o] 
		
		eg: var str = 'a,s,d,f' var arr1 = str.split(',') ==> [a,s,d,f]  这里就需要传入逗号切割符
		
	Array.find(function(value) {
		return value > 2
	} )  ==>  查找到符合条件的值 直接返回对应的项 如果查找不到 则 返回undefined
	
	arr.findIndex(funciton(value){return value>2}) 此返回的是 符合条件的值的下标，如果 没有符合的 则返回-1
	
		比较 es5 indexOf  传参为想要得到的项，查找到对应项 返回对应项的下标 查找不到 返回 -1 
				 lastIndexOf() 也是一样 只是从后往前
	arr.fill()
		作用 填充数组
		只有一个 参数的时候 是全部替换数组的值
		两个参数的
Array
	①创建的方式
		var A = new Array(3)  //创建指明的是数量
		var B = new Array('aaa')  //创建指明的是内容
		var C = ['a','b']
		
	② var color = ['a','b','c'];
	
	  可以利用 数组的长度 length 来删除/添加 数组的末尾项
		color.length=2 ==>color=['a','b']; // 删除
		color[color.length] = 'fff' ==>color=['a','b','c','fff']  //添加
	  利用下标来 直接修改数组的值
		color[1] = 'fff'  ==> color=['a','fff','c']
	
	③ 判断是否是数组 instanceof （但是存在单一环境局限性，多个环境的话 会互相应影响，导致不准确）
	  可以使用 Array.isArray(value) 来做判断
	 
	④ 数组的转换
		每个对象都有这个三个方法,不影响原数组的值，会输出一个新的值
			
		一 toString() 将数组转换为都还好链接的字符串
		二 valueOf() 将数组值 原样输出
		三 toLocaleString() 将数组显示为当地数字 就 时间为例子 美国的/中国的日期格式显示对应 逗号链接的字符串
		四 join('') 将数组的每一项通过传递的参数进行连接，输出一个对应链接符的字符串
			eg: var C = ['a','b'] var mm = C.join('??') ==> mm = 'a??b'
	⑤ 栈方法 (LIFO) ==> (Last In First Out)
		push() 像数组的末尾添加一个值，并修改数组的length,原数组增加一个值。
			返回的是数组的长度 var C = ['a','b']; var m = C.push('c'); m=3;  重点
		pop() 删除数组末尾的最后一个值,原数组删除一个值
			返回值是删除项 	   var C = ['a','b']; var m = C.pop(); m='b';  重点
	
	④ 队列方法 （FIFO）===> (First In First Out)
		push()
		
		shift()  删除数组的第一个元素
				 返回值是删除项
		unshift()  向数组前面添加项
				 返回的是数组长度
	⑦数组排序
		reverse()  数组反向排序 
				 返回的是排序过后的数组
		sort()  按照顺序进行排序
				返回的是 排序过后的数组
			使用方法
				var A = [1，3，2];
				var B = A.sort(function(a,b){
						return a-b //返回的是升序排列 // B = [1,2,3];
						return b-a //返回的是升序排列 // B = [3,2,1];
					})  
	⑧数组链接
		concat() 将拼接数组，不只是链接数组，可以连接字符串, 可以连接多个
				 返回值是 链接过后的数组
				var A = [1，3，2];
				var newA = A.concat('aa',[99,88,77]); ==>newA = [1,3,2,'aa',99,88,77]
		slice() //英文 切片  切割数组的 
				返回一个新的数组，不会影响原数组
			使用方法	
				传入一个参数 会被认为是起始位置，截取从该位置开始 包含该位置
				传入两个参数  会被认为是起始位置 终止位置  字符串开始截取的位置 从这项开始 这项 是在的
			var A = [1，3，2];
			var B = A.slice(1) // B = [1,2] 错的 ==> 正确的结果为 B = [3,2] 
			
		splice() //返回删除的数组项
			使用方法
				三个参数 
				第一个参数树 开始的位置 是索引 // 
				第二个参数是 要从该位置开始删除几项  是删除数组对应的项
				第三个参数是要替换 或者 添加的项
				返回删除的项/原数组会受到影响
					var A = [1，3，2]; var m=A.splice(0,1); ==>  A = [3,2]  这是删除     m='1'
					var A = [1，3，2]; var m=A.splice(0,1,"aaa"); ==>  A = ['aaa',3,2]  这是替换  m='1'
					var A = [1，3，2]; var m=A.splice(0,0,"aaa"); ==>  A = ['aaa',1,3,2]  这是增加   m=''
		查找对应的项的索引
	
	⑨查找位置
		indexOf() 查找到对应的项 返回对应项的下标/查找不到的话 返回-1
			使用方法
				传入一个参数的  参数会被作为传入的项 进行查找 
				传入两个参数的话  第一个参数是要查找的项  第二个参数是下标从什么地方开始
		lastIndexOf() //从数组的末尾 向前查找 返回的是 数组 小标 正向数的不是 倒着数的
	
	⑩迭代方法
		一 筛选
			every() 返回的值 为Boolean
				var A = [1,2,8,6,24,5]  
				var k =	A.every(function(item,index,array //该参数可以省略){
						return item > 2;  //此处校验的是所有的项// 如果有一项不符合则 直接返回 false
					})
					
					k = false;
			some()  返回的值 为Boolean
				var A = [1,2,8,6,24,5]  
				var k =	A.filter(function(item,index,array //该参数可以省略){
						return item > 2;  //此处校验的是所有的项// 如果有一项不符合则 直接返回 false
					})
					k = true
			filter() 返回的值 过滤后的数组
				var A = [1,2,8,6,24,5]
				var m =	A.filter(function(item,index,array //该参数可以省略){
						return item > 2;  
					})
					m = [8,6,24,5]
			map() 针对每一项进行特定的复制运算 并返回这个运算后的数组
				var A = [1,2,3]
				var m =	A.map(function(item,index,array //该参数可以省略){
						return item*2;  
					})
					m = [2,4,6]
			forEach() 类似于for 循环 没有返回值
			
	十一合并数组
			reduce()
				var A = [1,2,3]
				var m =	A.reduce(function(prev,cur,index,array //该参数可以省略){
						return prev+cur;  
					}) ==> m = 6; //数组项想 数值类型 参数相加 求和 
								  //数组项想 其他类型 拼接字符串 对象的话 会显示 object
			reduceRight() //从后往前处理
	
基本包装类型
	Number/String/Boolean

	Boolean
	
		var s1="aaaaa"  var s2 = s1.substring(2); 
			==> 实际内部执行过程
				var s1 = new String('aaaaa');
				var s2 = s1.substring(2);  
					//只能获取原型链上的方法  s1.color = 'red' 访问 s1.color ==> undefinde; 
						//因为当访问s1.color 的时候  上一步 设值得s1 已经销毁了 此时的s1 是一个新的s1
				s1 = null; //销毁s1
				
	特殊的地方
		
	String
		
		查找对应位置的字符
		
		charAt() // 返回对应下标的对应的字符
			参数表示 要查询的下标 
			eg: var a = 'qwert'; var m = a.charAt(1); ==> m='w'  ==>可以通过  [] 来访问 m = a[1]  ==> m ='w'
		
		charCodeAt() // 返回对应下标的对应的字符编码
			eg: var a = 'qwert'; var m = a.charAt(1); ==> m=119;
		
		fromCharCode()  参数为数字 
						返回的值是一个字符
		
		查找字符对应的位置
		
		都可以接受两个参数 第一个参数是要查找的项 第二个是从什么位置开始
		
		indexOf 
		lastIndexOf() 
		
		concat() //合并多个字符串 ,参数都好隔开 如果穿入的为数组 则调用 数组的 toString() 采用字符串连接方式 进行拼接
				 //不影响 原数组
			eg: var a = 'qqqqq' var m = a.concat('a',['sss','ddd','fff'],444) ==> m=qqqqqasss,ddd,fff444
		
		//截取字符串
		
		slice()  //切割字符串 和 数组是一样的
			一个参数的时候表示从哪一项开始 
			两个参数的时候 第一项表示从哪一项开始  第二项表示到哪一项之前结束 
		subString()  //和slice 是一样的
		subStr()  //不同的是 第二个参数 是有要得到几个字符 
		
		如果 只有一个参数  那么意思就是从该位置开始截取到最后
		
		当传递 负数的时候
			slice  会将所有的负参数相加字符串的总长度
			subStr 会将第一个参数加上字符串的总长度，第二个参数 如果也为负数 会被直接置为零
			substring  会将所有的负参数 转换为 0
		
		trim()  删除所有的空格
		trimLeft()  trimRight() 
		
		toLowerCase()
		toUpperCase() 
		
		toLocaleLowerCase()
		toLocaleUpperCase() 
		
		字符串的匹配方法
		match() 参数是一个正则表达式
		
			返回一个数组 每一个匹配到的都在
				var a = 'mat cat uat' ; var s = a.match(/at/g); s=['at','at','at']; //不带g的话 只要查找到就立即返回 一个项的数组
		search() 参数是一个正则表达式
		
			返回零或者负一
				var a = 'mat cat uat' ; var s = a.search(/at/); ===>s=1;
				
		replace()  第一个参数是正则表达式  第二个参数可以是一个字符串(表示要替换的项) 也可以是一个function()
			var a = 'mat cat uat'; var mm = a.replace(/at/,'000'); mm = 'm000 cat uat';
			var a = 'mat cat uat'; var mm = a.replace(/at/g,'000'); mm = 'm000 c000 u000';
								   var mm = a.replace(/ma|ca/g,function(match,pos,originText){
										//match  匹配到的项 
										//pos  匹配到项首字母的出现位置
										//originText 搜索的字符串 就是 a 本身
										
										console.log(match)  //===>'ma' / 'ca'
										
								   })
		split() 可接受两个参数 
					第一个参数是正则表达式 第二个参数是一个数字 表示 转换为数组的长度(可以省略)
				
					var a = 'mat cat uat'; var mm = a.split(' ',2); ===> mm = ['mat','cat']
					
		localeCompare() 比较两个字符串 返回-1表示它在前 返回0 表示相等 返回1表示在之后
			var a='yellow'; 
			var b=a.localeCompare('black') ==> b = 1;
	Boolean
		
		var value = 12 ;
		
		var number = Number(value);  //基本类型
		
			alert(typeof number) //Number
		
		var number = new Number(value)  //引用类型
			
			alert(typeof number) //object
			
			==> var number = Boolean(false); //基本类型  var result = number && true; result = false;
				
			==> var number = new Boolean(false);  //引用类型 var result = number && true; result = true;
					==> 分析 number = object Boolean(object // 不为空就是 true ) 所以得出上值
	
	Number
		
		① number.tostring() //里边可以限制 是几进制的  //2，8，10，16
			eg: var num = 10; console.log(num.toString(2)) ==> 1010
		② number.toFixed(2)
			eg: var num = 10.167; var aa = num.toFixed(2) ==>  aa=10.17
		③ number.toPrecision() //是根据需要自动显示的指数格式 参数表述数值的位数  //单词意思 精度
			eg: var num = 10; var aa = num.toPrecision(1)  ==> aa = 1e+1;
		
transform  //释意  运动
	translate(x,y)  2D 转换 沿着X和Y 轴平移  //释意 转化
	3D  translate3D(x,y,z)
	translateX() 沿着 X 轴平移
	translateY() 沿着 Y 轴平移
	translateZ() 沿着 Y 轴平移
	
	scale(x,y)  沿着X或Y 缩小 或 放大  //释义  比例
	scale3D(x,y,z)
	scaleX() 
	scaleY()
	scaleZ()
	
	rotate(angle) // 释义 旋转   旋转这个图片
	rotate3D(x,y,z,angle)
	单独设置只有3D 有
	rotateX(angle)
	rotateY(angle)
	rotateZ(angle)
	
	skew(x-angle,y-angle) //释义 歪斜 以X 轴为基准进行歪斜
	skewX()
	skewY() 
	
	perspective() 定义三D 转换的透视试图
	
	
	3D 独有
	transform-origin  运动原点
	
	其余 有待研究
	
	http://www.runoob.com/css3/css3-3dtransforms.html
	
transition
	transiton-property    //运动的名称
	transiton-duration	  //运动时间
	transiton-timing-function  
		linear   以相同速度开始至结束的运动
		ease     以慢速开始 然后变快 然后慢速结束 
		ease-in  以慢速开始的过度效果
		ease-out 以慢速结束的过渡效果
		ease-in-out 以慢速开始和结束的过度效果
		cubic-bezier(n,n,n,n) 
	transiton-delay 延迟
	
	缩写 transition: property duration timing-function delay;
	
animation
	animation-name              keyframe名称
	animation-duration          花费的时间
	animation-timing-function   速度曲线
		linear   以相同速度开始至结束的运动
		ease     以慢速开始 然后变快 然后慢速结束 
		ease-in  以慢速开始的过度效果
		ease-out 以慢速结束的过渡效果
		ease-in-out 以慢速开始和结束的过度效果
		cubic-bezier(n,n,n,n)
	animation-delay             延迟
	animation-iteration-count   次数（infinite  无线次数）
	animation-direction         规定是否轮流反向播放动画（normal | alternate）
	缩写 animation: name duration timing-function delay iteration-count direction;
	
	两种动画的编写方式
	@keyframe 运动名称 {
		from { left: 0px }
		to { left: 200px }
	}
	@keyframe 运动名称 {
		0% { left: 0px }
		10% { left: 200px }
		20% { left: 200px }
		100% { left: 200px }
	}
	
省略号

	单行
	overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
	
	多行
	overflow : hidden;
	text-overflow: ellipsis;
	display: -webkit-box;
	-webkit-line-clamp: 2;
	-webkit-box-orient: vertical;
	
	
	此属性不设置  默认是 border-box
	box-sizing：规定边框算不算高度的问题
		content-box 设置的 height 不包含 border 即  元素总高度 = height + border
						如：设置了 height:100px;再设置border：10px solid red; 那么 获取元素高度的时候就为 120
		border-box  设置的 height 再设置border 是包含在height内部的  
						如：设置了 height:100px;再设置border：10px solid red; 那么 获取元素高度的时候就为 100 

css3 选择器
	
	div,p 并列关系
	div>p 归属关系  m:选择div 下所有的P
	div+p 并列关系  m: 选择紧挨 div 的所有p 元素
	
	//属性过滤不用加引号
	a[target] 相应属性的选择  m: 选择a元素 属性名为 'target' 的元素
	a[target=aa] 相应属性和值的选择  m:选择属性名为 'taget' 其值为'aa' 的a元素
	a[target~=aa] 相应属性和值的选择  m:选择属性名为 'taget' 其值中，包含'aa' 单词的a元素 要以 空格隔开
	a[target|=aa] 相应属性和值的选择  m:选择属性名为 'taget' 其值中，包含'aa' 单词的a元素 要以 -隔开
	
	//记得加引号（类似于正则查找）
	a[target^='aa'] 选取以aa 字符开头的 该属性 a 元素
	a[target$='aa'] 选取以aa 字符结尾的 该属性 a 元素
	a[target*='aa'] 选取包含aa 字符串的 该属性 a 元素
	
	//target 可设置为任何属性
	
	a:hover 
	a:link  选择未被访问的链接
	a:visited  选择所有已被访问的链接
	a:active 点击链接的时候
	
	input:focus 选择获得焦点的 input 

	:first-letter  p:first-letter 选择p元素内容的首个字母 进行样式设置
	:first-line    p:first-line 选择p元素内容的首行字母 进行样式设置
	
	:first-child  选择父元素的首个(结构上的) 子元素 
		p:first-child 任何父元素的首个p子元素 前边可以限制区域的 元素内部元素的首个元素是p元素才能被选取
	:last-child
	:only-child   选择父元素唯一子元素
	:nth-child(n)  选择父元素的第n个元素
	:nth-last-child(n)  倒着数的
  	
	:first-child-type  选择父元素的首个（类型上的）子元素  
		选择父元素内部 该类型的首个元素
	:only-of-type  选择父元素下 唯一类型的 子元素
	:nth-of-type(n) 
	:nth-last-of-type(n) 
	
	:root 选择文档的根元素 (:root) 就是这么用
	p:empty 选择没有子元素的每个p元素 
	
	:target   选择当前活动的#news 元素
		<p><a href="#news1">跳转至内容 1</a></p>
		<p id="news1"><b>内容 1...</b></p>
	
	input:enabled  选择每个 启用的input 元素
	input:disabled 选择每个禁用的input 元素
	
	::selection 选取被用户选取的元素部分
	
	
	:before 在元素内容之前插入内容 <p>aaa</p>  p:before { content:'台词 ：' } ==>  台词：aaa
	:after 在元素内容最后插入内容 <p>aaa</p>  p:before { content:'台词 ：' } ==>   aaa台词：

	:lang('en')  选择有以 en 开头的lang 属性的 每个 p 元素
	
	p~ul 选取前面有p元素的 每个ul 元素
	
						
BOM => windows 双重角色  
	   既是 javascript 访问浏览器窗口的一个接口
	   又是 ECMAScript 规定的Global 对象
	
	var a=1;  window.a = 1; ===> delete window.a ===>抛错 
			  原因: [[configurable]]  被设置为了 false
			  
	尝试访问 未声明的属性 会报错
		var a = b ==> 抛错 a = undefinded
		var a = window.b  ==> 不会报错 因为是 属性查询
	
	screenX/screenY(chrome)  screenLeft/screenTop(IE,chrome)
		moveTo(x,y) x y  分别表示 窗口要移动到的新坐标
		moveBy(x,y) x y  分别表示 窗口需要移动的 x和y 方向上 对应的距离
	
	innerWidth/innerHeight  
	outerWidth/outerHeight
	
	document.documentElement.clinetWidth
	document.documentElement.clinetHeight
	
	document.body.clinetWidth
	document.body.clinetHeight
	
	compatMode  标准模式 （不理解）
	
		混杂模式
			document.body
		标准模式	
			document.documentElement
			
	document.documentElement.clinetWidth
	document.documentElement.clinetHeight
	
	document.body.clinetWidth
	document.body.clinetHeight
	
	window.open()
	
	var timeoutID = window.setTimeout(function(){
		//内容
	},100)  //  timeoutID 为setTimeout（超时调用） 返回唯一的标志ID 
	
	要取消 超时调用 则 将 ID 传递给 clearTimeout(ID) 将对应的 clearTimeout 取消掉
		
		setInterval clearInterval() 同理可得
	
	提示框
		alert('内容') 用户只能点击确定
		
		confirm('内容')  用户可以点击或取消 
			点击 ok 返回 true
			点击 cancle 返回 false
			if(confirm('内容')) //相关处理
		
		prompt()  带有输入框的提示框 
			用户提交内容 点击 会将 填写内容返回
			否则 返回 ‘’ 或 null
		
		window.find('内容') 查找 整个页面的内容 是否含有‘相关内容’
			有 则 返回 true
			没有 返回 false
	
	window.location === document.location  引用的是一个对象
	
	location
		location.href //返回整个url
		location.serch  // 返回从 ？ 开始到最后的 不知道包含#号部分
		location.protocol // 返回协议 eg: 'http:'
		location.pathname   //返回文件目录部分
		location.hash  // 返回 # 开始到最后的
		location.port  //返回端口 
		location.host  //返回服务器名字和端口号
		location.hostname //返回不带端口号的服务器名字
		
		截取字符串的时候 记得 使用 decodeURIComponent(value) 解码
	
	location.assign() 参数为URL 
		功能同等于 window.location = url  / location.href = url
		
	location.replace() 
		改变页面 url 后 不会改变留下 浏览记录
		
	location.reload() 刷新 页面  //有可能从缓存中加载
	location.reload(true) 刷新 页面  //从服务器重新加载
	
	识别客户端浏览器
	
	navigator.userAgent  浏览器的用户代理字符串
	navigator.userLanguage  操作系统的默认语言
	navigator.userProfile   借以访问用户个人信息的对象
	navigator.vendor   浏览器的品牌
	navigator.vendorSub   有关供应商的次要信息
 	navigator.plugins  浏览器中安装的插件信息的数组
 		
	navigator.plugins[i].name   插件的名字
	navigator.plugins[i].description    插件的描述
	navigator.plugins[i].filename   插件的文件名
	navigator.plugins[i].length   插件所处理的MIME类型数量
		
	screen.acailHeight	
	screen.acailWidth	
	screen.left	
	screen.top	
	screen.width	
	screen.height	
	
	histoty.go(-1) 后退一页
	histoty.go(1) 前进一页
	histoty.go(2) 前进两页
	histoty.go('www.baidu.com')  如果浏览记录里有这个记录，则直接跳到这个记录里
								 如果没有记录， 那么这个方法什么也不做
								 如果有多条该记录则以 最新的那条记录为准
	histoty.back()
	histoty.forward() 
								 
事件
	每个事件包含三个阶段
		事件捕获阶段  document-elelment(html)-element(body)-element(div）
		处于目标阶段 
		事件冒泡阶段  element(div）-element(body)-elelment(html)-document
	
	DOM0事件处理程序
		var btn = document.getElementById('myBtn')
			btn.onclick=function(){
				alert(this.id)   
			}   ==>  myBtn  
				作用域是 元素的作用域内
	
	DOM2级事件处理程序
		非IE 的情况下 event 两种情况都可以作为参数进行传递 event 对象
		var btn = document.getElementById('myBtn')
			
			btn.addEventListener("click",function(){
				alert('nnn')
			},false) 此处的false 表示冒泡阶段调用事件处理程序
					 此处的true  表示捕获阶段调用事件处理程序
			btn.removeEventListener("click",function(){
				alert('删除') 
			},false)  这样处理 是无效的
			
			正确的处理方式是：
			var handler = function(){...}
			btn.addEventListener("click", handler, false)
			btn.removeEventListener("click", handler, false)
		
			IE的处理 
			DOM0 
				event 是通过 window.event 来访问的
			
			btn = document.getElementById('myBtn')
			btn.onclick=function(){
				alert(this.id)   
			}   ==>  myBtn  
				 注意是onclick
				（IE只有事件冒泡流程）
				作用域是全局 ==> window
			
			DOM2 是通过传参形式进行event的传播的
			btn.attachEvent("onclick",function(){ this === window })
			btn.detachEvent("onclick",function(){ this === window }) //此处删除处理程序和上部是一致的
			
			window.event.cancleBubble = true  取消事件冒泡
			window.event.srcElement ==> 相当于 target
			window.event.returnValue = false  取消事件默认行为
			type
			
	event
		bubbles  表明事件是否冒泡
		stopImmediatePropagation() dom3 待了解
			取消事件的进一步冒泡或捕获 同时组织组织任何事件处理程序被调用
		stopPropagation()  阻止事件冒泡或捕获 bubbles为true 则可取消
		
		cancelable  取消事件的默认行为
		preventDefault()   cancelable 为true 则可调用该方法
		
		currentTarget  
			事件处理程序内部 this  始终等于  currentTarget
			就是那个元素上 注册注册注册 了事件处理程序
		target  就是 时间的目标 也就是 时间处于目标阶段的元素
		
		detail  与事件相关的细节信息
		type  事件的类型
		trusted  为true 则表示时间是浏览器生成的 为false 表示事件开发人员通过 javascript 生成的（dom3）
		
		eventPhase  时间的相应阶段
						1 代表捕获阶段  2 表示处于”目标阶段“  3 处于冒泡阶段
									目标阶段属于冒泡阶段 但是 eventPhase 的值是 2
									但出于 目标阶段时  event.eventTatget === event.target
						
	UI事件
		load()
			1. 页面加载完触发
			2. 所有框架处理完触发
			3. img 资源加载完触发
			4. 当嵌入的内容 加载完毕时在<object>元素上触发
		error()
			针对上面每个的失败处理
		unload()
			当页面卸载后触发
		abort()
			1. 当用户停止下载过程时触发
			2. 嵌入的内容没有加载完时触发
		select()
			当用户选择 input / textarea 中的一个或多个字符串时触发
		resize()
			当窗口或框架大小变化是在 window 或 框架上面触发
		scroll()
			当用户滚动带滚动条的元素的内容时触发 
	
	焦点事件
		focus()
		blur() 
	
	鼠标指针在视口的位置 即相对于整个浏览器窗口的
		clientY clinetX
	鼠标指针相对于页面的位置
		pageX pageY
		
		//计算相对页面的滚动位置
		if(event.pageX == undefined){
			pageX = event.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft)
		}
		
	鼠标指针相对与 整个屏幕的
		screenX screenY 
	这是IE的
	offsetX
		光标相对目标元素边界的x坐标
	offsetY
		光标相对目标元素边界的y坐标
		
	moseout,mouseover
		页面中只有一个div,鼠标指针在div上
			当鼠标移出div时，div上执行的是mouseout  body 上执行的是 mouseover
	mousedown,mouseup
		只针对鼠标的点击事件
			会返回一个button 属性 event.button
				0 没有按下按钮
				1 按下鼠标主按钮（左键）
				2 按下鼠标次按钮（右键）
				3 同时按下左右键
				4 按下中间的鼠标按钮
				5 左中
				6 右中
				7 同时按下三个鼠标按钮
				
	mousedown和mouseup 两个事件都完成才算一个点击
		detail中包含里一个属性 表示点击的次数 如果 mousedown 和 mouseup 换了位置该属性会被置为0
	
	mouseWheel
		滚轮事件 
		btn.addEventListener("mouseWheel", function(event){
			console.log(event.mouseWheel)
		}, false)
		
	键盘事件
		keydown  
			键盘按下任意键触发（如果按住不放会重复触发该事件）
		keypress 
			键盘字母键按下触发（如果按住不放会重复触发该事件）
		keyup
			释放按键时触发
		
		event.keycode
	
	textInput,keypress
		任何可以获得焦点的元素都可以触发keypress
		只有可编辑区域才能触发除法 textInput
		
		textInput 用户按下实际输入的字符时触发
		
		keypress 按下那些能够影响文本的现实的键时触发 
		
		btn.addEventListener("textInput", function(event){
			event.data 
			0 不确定浏览器是怎么输入的
			1 键盘输入的
			2 文本粘贴过来的
			3 拖放进来的
			4 文本使用 IME 输入的
			5 文本通过在表单中选择某一项输入的
			6 手写输入
			7 语音输入的
			8 几种方法组合输入的
			9 脚本输入的

		}, false)
		
	contextmenu
		修改右键菜单
		
		取消右键菜单 event.preventDefault() || event.returnValue = false 
		div.addEventListener("contextmenu", funciton(){
			div2.style.left = event.clientX + "px"
			div2.style.top = event.clientY + "px"
			div.style.visibility = "visible"
		})
	
	window.orientation
		判断屏幕方向
			0 肖像模式 
			90 向左旋转的的横向模式 （home键在右侧）
			-90 向左旋转的的横向模式 （home键在左侧）
			
	touchstart
	touchmove
	touchend
	touchcancel
	
	touches 当前跟踪触摸操作的 Touch 对象的数组
	targetTouches: 特定于事件目标的Touch对象的数组
	changeTouches: 自上次触摸以来发生了什么改变的Touch对象的数组
	
	每个touch对象包含
		clientX
		clientY
		screenX
		screenY
		pageX
		pageY
		identifier 
		
	事件委托
		原理是利用事件冒泡机制
			可通过捕获 target.id 进行相应事件的控制
	<div id=“a”>
		<p id="b"></p>
		<p id="c"></p>
		<p id="d"></p>
	</div>
		
		$("#a").click(function(e){
			swith(e.target){
				case: "b":
					dosomething
				case: "c":
					dosomething
				case: "d":
					dosomething
			}
		})
		
		
		
		
		
	
	
		

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	instanceof 实例（用于检测数组）	
		
		
		
		
		
		
		
		
		